clear;
close all;

img = imread('Screenshot_1.png'); % загрузка изображения из папки с кодом
img = im2double(img); % приведение к вещественному типу данных

% отображаем изображение:
figure; 
imshow(img); 
title('Исходное изображение');

n = 32; % размер блока nxn
% дополняем исходное изображение нулями, чтобы делилось на блоки:
[W, H, C] = size(img);
newW = W;
newH = H;
while rem(newW,n)~=0; newW=newW+1; end
while rem(newH,n)~=0; newH=newH+1; end
addedImage = zeros(newW, newH, C);
addedImage(1:W, 1:H, :) = img;
nw = newW/n;
nh = newH/n;

block{nw, nh} = []; % создаем массив ячеек с блоками изображения
newImage{nw, nh} = []; % массив ячеек для конечного (зашифрованного) изображения

q = 0.2; % коэффициент энергии для встраивания
w = 2; % ширина окрестности (число соседей слева, сверху, справа и снизу от модифицируемого пикселя)
tau = 0.4; % коэффициент для определения искаженных блоков
N = (n - 2 * w) * (n - 2 * w); % площадь центральной области изображения с отступом в w пикселей от краев 
s_rand = randi(2, 1, N) - 1; % массив случайных чисел для разбавления перцептивного хеша

% основной цикл - модификация блоков изображения:
I=1; % номер блока по вертикали
for i=1:n:newW
    J = 1; % номер блока по горизонтали
    for j=1:n:newH
        block{I, J} = addedImage(i:i+n-1,j:j+n-1,:); % заполнение массива ячеек с блоками изображения
        blockImage = block{I, J};
        grayBlockImage = rgb2gray(block{I, J}); % перевод в градации серого
        fourieAll = dct2(grayBlockImage); % вычисление ДКП
        cutFourie = fourieAll(1:8, 1:8); % выделение в матрице коэф-тов левого верхнего подблока 8х8
        vec = reshape(cutFourie', 1, []); % перевод матрицы в вектор
        t = mean(vec); % среднее значение полученного вектора
        
        % получение перцептивного хеш-кода h:
        h = vec;
        for k=1:size(h, 2)
            if(abs(vec(k))<t)
                h(k) = 0;
            else
                h(k) = 1;
            end
        end
        s = [h s_rand]; % соединение хеш-кода и массива случайных чисел
        
        % стеганографическое встраивание по методу Куттера-Джордана-Боссена:
        B = blockImage(:,:,3); % выделение синего цветового канала   
        % проходим по пикселям синего канала изображения:
        p = 1;      % номер встраиваемого бита сообщения
        for a = w + 1 : n - w
            for b = w + 1 : n - w
                % модифицируем пиксель в синем канале (прибавляем или вычитаем яркость в этом месте)
                B(a, b) = B(a, b) + (2 * s(p) - 1) * q * grayBlockImage(a, b);
                p = p + 1;
            end
        end
        
        % копируем исходное изображение и вставляем измененный синий канал обратно в контейнер:
        newBlockImage = blockImage;
        newBlockImage(:,:,3) = B;  % модифицированный блок изображения
        newImage{I, J} = newBlockImage; % заполняем массив блоков нового изображения
        J = J+1;
    end
    I = I+1;
end

newImage = cell2mat(newImage); % переводим блоки в формат изображения
% отображаем изображение:
figure;
imshow(newImage);
title('Зашифрованное изображение');
%imwrite(newImage, 'shifred.png');

%% Аутентификация полученного изображения

% имитация изменений, внесенных злоумышленником:
% badImage = imread("badcsf.png"); 
% badImage = im2double(badImage);
gotImage = newImage;
%gotImage(420:650, 230:850, :) = 0;
%gotImage(20:200, 10:100, :) = 1;
gotImage(200:300, 300:400, :) = gotImage(300:-1:200, 400:-1:300, :);

% дополняем изображение, чтобы делилось на блоки:
[W, H, C] = size(gotImage);
addedGotImage = zeros(newW, newH, C);
addedGotImage(1:W, 1:H, :) = gotImage;
% отображаем полученное изображение:
figure;
imshow(addedGotImage);
title('Полученное изображение');

isAuthentic = zeros(I-1,J-1); % создаем массив для аутентификации блоков
% тот же алгоритм, что и при шифровании
I=1;
for i=1:n:newW
    J = 1;
    for j=1:n:newH
        block{I, J} = addedGotImage(i:i+n-1,j:j+n-1,:);
        blockImage = block{I, J};
        grayBlockImage = rgb2gray(block{I, J});
        fourieAll = dct2(grayBlockImage);
        cutFourie = fourieAll(1:8, 1:8);
        vec = reshape(cutFourie', 1, []);
        t = mean(vec);
        h = vec;
        for k=1:size(h, 2)
            if(abs(vec(k))<t)
                h(k) = 0;
            else
                h(k) = 1;
            end
        end
        s = [h s_rand];
        
        % извлечение информации
        s_ = s * 0; % сюда будем записывать извлеченные биты сообщения
        B = blockImage(:,:,3); % выделяем синий цветовой канал
        % проходим по пикселям синего канала изображения:
        p = 1;      % номер считываемого бита
        for a = w + 1 : n - w
            for b = w + 1 : n - w
                hs = B(a - w : a + w, b);	% пиксели сверху и снизу от пикселя (a,b)
                vs = B(a, b - w : b + w);	% пиксели слева и справа от пикселя (a,b)
                b_ = (sum(hs) + sum(vs) - 2 * B(a, b)) / (4 * w);   % среднее
                % cравниваем значение пикселя с величиной среднего соседей
                % если больше, то бит сообщения = 1, если меньше - 0
                s_(p) = B(a, b) > b_;
                p = p + 1;
            end
        end
        
        D = pdist([s; s_], 'hamming'); % вычисление расстояния по Хэммингу  
        isAuthentic(I, J) = D; % заполение аутентификационного массива значениями расстояний
        if(D>tau)
            block{I, J}(:, :, 1) = 1; % окрашивание блока в красный цвет, если расстояние больше tau, 
            % т.е. блок скорее всего был изменен злоумышленником
        end
        J = J+1;
    end
    I = I+1;
end

% % автоматический подбор параметра тау
% tau = mean2(isAuthentic); % среднее значение расстояний D в массиве
% for i=1:size(block, 1)
%     for j=1:size(block, 2)
%        if(isAuthentic(i, j)>3*tau)
%            block{i, j}(:, :, 1) = 1; % если значение расстояния для блока втрое выше среднего, 
%            %этот блок окрашивается красным
%        end
%     end
% end

% получаем маркированное изображение и выводим его:
markedImage = cell2mat(block); 
figure;
imshow(markedImage);
title('Изображение с помеченными изменениями');


